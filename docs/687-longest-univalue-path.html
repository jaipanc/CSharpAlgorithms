<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#57B747"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2026-02-07T22:58:26.9476106"><title>687: Longest Univalue Path | DSA using C#.NET</title><script type="application/json" id="virtual-toc-data">[{"id":"what-the-problem-is-asking-in-simple-words","level":0,"title":"What the problem is asking (in simple words)","anchor":"#what-the-problem-is-asking-in-simple-words"},{"id":"key-dfs-idea","level":0,"title":"Key DFS idea","anchor":"#key-dfs-idea"},{"id":"visual-example-step-by-step","level":0,"title":"Visual Example (step-by-step)","anchor":"#visual-example-step-by-step"},{"id":"step-by-step-dfs-postorder","level":0,"title":"Step-by-step DFS (postorder)","anchor":"#step-by-step-dfs-postorder"},{"id":"why-leftarm-rightarm-matters","level":0,"title":"Why ‚ÄúleftArm + rightArm‚Äù matters","anchor":"#why-leftarm-rightarm-matters"},{"id":"c-dfs-template-core-logic","level":0,"title":"C# DFS template (core logic)","anchor":"#c-dfs-template-core-logic"},{"id":"1-the-real-mental-model","level":0,"title":"1Ô∏è‚É£ The real mental model","anchor":"#1-the-real-mental-model"},{"id":"2-better-naming","level":0,"title":"2Ô∏è‚É£ Better naming","anchor":"#2-better-naming"},{"id":"3-clean-c-code-with-clear-naming","level":0,"title":"3Ô∏è‚É£ Clean C# code with clear naming","anchor":"#3-clean-c-code-with-clear-naming"},{"id":"4-visual-walkthrough-with-new-names","level":0,"title":"4Ô∏è‚É£ Visual walkthrough with new names","anchor":"#4-visual-walkthrough-with-new-names"},{"id":"5-one-sentence-rule","level":0,"title":"5Ô∏è‚É£ One-sentence rule","anchor":"#5-one-sentence-rule"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.25.3-b857/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="https://www.python.org/static/apple-touch-icon-144x144-precomposed.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="687: Longest Univalue Path | DSA using C#.NET"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="DSA using C#.NET Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/https://github.com/jaipanc/CSharpAlgorithms/tree/master/docs/687-longest-univalue-path.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="687: Longest Univalue Path | DSA using C#.NET"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/https://github.com/jaipanc/CSharpAlgorithms/tree/master/docs/687-longest-univalue-path.html#webpage",
    "url": "writerside-documentation/https://github.com/jaipanc/CSharpAlgorithms/tree/master/docs/687-longest-univalue-path.html",
    "name": "687: Longest Univalue Path | DSA using C#.NET",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentationhttps://github.com/jaipanc/CSharpAlgorithms/tree/master/docs/#website",
    "url": "writerside-documentationhttps://github.com/jaipanc/CSharpAlgorithms/tree/master/docs/",
    "name": "DSA using C#.NET Help"
}</script><!-- End Schema.org --></head><body data-id="687-Longest-Univalue-Path" data-main-title="687: Longest Univalue Path" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="üå≥-Depth-First-Search-DFS.md|üå≥ Depth-First Search (DFS)"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>DSA using C#.NET  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="687-Longest-Univalue-Path" id="687-Longest-Univalue-Path.md">687: Longest Univalue Path</h1><section class="chapter"><h2 id="what-the-problem-is-asking-in-simple-words" data-toc="what-the-problem-is-asking-in-simple-words">What the problem is asking (in simple words)</h2><p id="z95rfnv_14">You need the <span class="control" id="z95rfnv_17">longest path (number of edges)</span> in the tree where <span class="control" id="z95rfnv_18">every node on that path has the same value</span>.</p><ul class="list _bullet" id="z95rfnv_15"><li class="list__item" id="z95rfnv_19"><p id="z95rfnv_21">The path can go <span class="control" id="z95rfnv_22">left &harr; node &harr; right</span> (it doesn&rsquo;t have to start at root).</p></li><li class="list__item" id="z95rfnv_20"><p id="z95rfnv_23">Count <span class="control" id="z95rfnv_24">edges</span>, not nodes.</p></li></ul></section><section class="chapter"><h2 id="key-dfs-idea" data-toc="key-dfs-idea">Key DFS idea</h2><p id="z95rfnv_25">At every node, compute:</p><ul class="list _bullet" id="z95rfnv_26"><li class="list__item" id="z95rfnv_30"><p id="z95rfnv_32"><code class="code" id="z95rfnv_33">leftArm</code> = longest same-value chain going <span class="control" id="z95rfnv_34">down</span> into the left child</p></li><li class="list__item" id="z95rfnv_31"><p id="z95rfnv_35"><code class="code" id="z95rfnv_36">rightArm</code> = longest same-value chain going <span class="control" id="z95rfnv_37">down</span> into the right child</p></li></ul><p id="z95rfnv_27">Then:</p><ul class="list _bullet" id="z95rfnv_28"><li class="list__item" id="z95rfnv_38"><p id="z95rfnv_41">A path that <span class="control" id="z95rfnv_42">passes through</span> this node can be <code class="code" id="z95rfnv_43">leftArm + rightArm</code></p></li><li class="list__item" id="z95rfnv_39"><p id="z95rfnv_44">Update a global answer with that</p></li><li class="list__item" id="z95rfnv_40"><p id="z95rfnv_45">Return to parent: only <span class="control" id="z95rfnv_46">one arm</span> can be extended upward &rArr; <code class="code" id="z95rfnv_47">max(leftArm, rightArm)</code></p></li></ul></section><section class="chapter"><h2 id="visual-example-step-by-step" data-toc="visual-example-step-by-step">Visual Example (step-by-step)</h2><div class="code-block" data-lang="none">
  ------     ------
        5
       / \
      4   5
     / \   \
    1   1   5
    
</div><section class="chapter"><h3 id="goal" data-toc="goal">Goal</h3><p id="z95rfnv_50">Find the longest path where all values are the same.</p><p id="z95rfnv_51">The best univalue path here is: <code class="code" id="z95rfnv_53">5 - 5 - 5</code> on the right side That has <span class="control" id="z95rfnv_54">2 edges</span>.</p></section></section><section class="chapter"><h2 id="step-by-step-dfs-postorder" data-toc="step-by-step-dfs-postorder">Step-by-step DFS (postorder)</h2><p id="z95rfnv_55">We compute from bottom to top.</p><section class="chapter"><h3 id="leaf-nodes" data-toc="leaf-nodes">Leaf nodes</h3><ul class="list _bullet" id="z95rfnv_60"><li class="list__item" id="z95rfnv_63"><p id="z95rfnv_66">Node <code class="code" id="z95rfnv_67">1</code> (left-left): no children &rarr; returns 0</p></li><li class="list__item" id="z95rfnv_64"><p id="z95rfnv_68">Node <code class="code" id="z95rfnv_69">1</code> (left-right): no children &rarr; returns 0</p></li><li class="list__item" id="z95rfnv_65"><p id="z95rfnv_70">Node <code class="code" id="z95rfnv_71">5</code> (right-right): no children &rarr; returns 0</p></li></ul><p id="z95rfnv_61">(Leaves return <span class="control" id="z95rfnv_72">0 edges</span> extending downward.)</p></section><section class="chapter"><h3 id="node-4-left-subtree-root" data-toc="node-4-left-subtree-root">Node <code class="code" id="z95rfnv_82">4</code> (left subtree root)</h3><div class="code-block" data-lang="none">
-------------
      4
     / \
    1   1
</div><ul class="list _bullet" id="z95rfnv_75"><li class="list__item" id="z95rfnv_83"><p id="z95rfnv_85">Left child value = 1 &ne; 4 &rarr; <code class="code" id="z95rfnv_86">leftArm = 0</code></p></li><li class="list__item" id="z95rfnv_84"><p id="z95rfnv_87">Right child value = 1 &ne; 4 &rarr; <code class="code" id="z95rfnv_88">rightArm = 0</code></p></li></ul><p id="z95rfnv_76">Update global:</p><ul class="list _bullet" id="z95rfnv_77"><li class="list__item" id="z95rfnv_89"><p id="z95rfnv_90"><code class="code" id="z95rfnv_91">best = max(best, leftArm + rightArm) = max(best, 0)</code></p></li></ul><p id="z95rfnv_78">Return upward:</p><ul class="list _bullet" id="z95rfnv_79"><li class="list__item" id="z95rfnv_92"><p id="z95rfnv_93">returns <code class="code" id="z95rfnv_94">max(0,0)=0</code></p></li></ul><p id="z95rfnv_80">‚úÖ Meaning: from node 4, there is <span class="control" id="z95rfnv_95">no same-value chain</span> you can extend upward.</p></section><section class="chapter"><h3 id="node-5-right-child-of-root" data-toc="node-5-right-child-of-root">Node <code class="code" id="z95rfnv_105">5</code> (right child of root)</h3><div class="code-block" data-lang="none">
    5
     \
      5
</div><ul class="list _bullet" id="z95rfnv_98"><li class="list__item" id="z95rfnv_106"><p id="z95rfnv_108">Left child is null &rarr; <code class="code" id="z95rfnv_109">leftArm = 0</code></p></li><li class="list__item" id="z95rfnv_107"><p id="z95rfnv_110">Right child value = 5 == 5 &rarr; <code class="code" id="z95rfnv_112">rightArm = 1 + dfs(rightChild)</code></p><ul class="list _bullet" id="z95rfnv_111"><li class="list__item" id="z95rfnv_113"><p id="z95rfnv_114">dfs(rightChild) returned 0, so <code class="code" id="z95rfnv_115">rightArm = 1</code></p></li></ul></li></ul><p id="z95rfnv_99">Update global:</p><ul class="list _bullet" id="z95rfnv_100"><li class="list__item" id="z95rfnv_116"><p id="z95rfnv_117"><code class="code" id="z95rfnv_118">best = max(best, 0 + 1) = 1</code></p></li></ul><p id="z95rfnv_101">Return upward:</p><ul class="list _bullet" id="z95rfnv_102"><li class="list__item" id="z95rfnv_119"><p id="z95rfnv_120">returns <code class="code" id="z95rfnv_121">max(0,1)=1</code></p></li></ul><p id="z95rfnv_103">‚úÖ Meaning: from this node 5, you can extend a chain of <span class="control" id="z95rfnv_122">length 1 edge</span> upward.</p></section><section class="chapter"><h3 id="root-node-5" data-toc="root-node-5">Root node <code class="code" id="z95rfnv_135">5</code></h3><div class="code-block" data-lang="none">
----------------
        5
       / \
      4   5
           \
            5
</div><p id="z95rfnv_125">We already know:</p><ul class="list _bullet" id="z95rfnv_126"><li class="list__item" id="z95rfnv_136"><p id="z95rfnv_138">dfs(left child 4) returned 0</p></li><li class="list__item" id="z95rfnv_137"><p id="z95rfnv_139">dfs(right child 5) returned 1</p></li></ul><p id="z95rfnv_127">Now compute arms at root:</p><ul class="list _bullet" id="z95rfnv_128"><li class="list__item" id="z95rfnv_140"><p id="z95rfnv_142">Left child value = 4 &ne; 5 &rarr; <code class="code" id="z95rfnv_143">leftArm = 0</code></p></li><li class="list__item" id="z95rfnv_141"><p id="z95rfnv_144">Right child value = 5 == 5 &rarr; <code class="code" id="z95rfnv_145">rightArm = 1 + dfs(rightChild) = 1 + 1 = 2</code></p></li></ul><p id="z95rfnv_129">Update global:</p><ul class="list _bullet" id="z95rfnv_130"><li class="list__item" id="z95rfnv_146"><p id="z95rfnv_147"><code class="code" id="z95rfnv_148">best = max(best, leftArm + rightArm) = max(1, 0 + 2) = 2</code></p></li></ul><p id="z95rfnv_131">Return upward (not needed further):</p><ul class="list _bullet" id="z95rfnv_132"><li class="list__item" id="z95rfnv_149"><p id="z95rfnv_150">returns <code class="code" id="z95rfnv_151">max(0,2)=2</code></p></li></ul><p id="z95rfnv_133">‚úÖ Final answer = <span class="control" id="z95rfnv_152">2</span></p></section></section><section class="chapter"><h2 id="why-leftarm-rightarm-matters" data-toc="why-leftarm-rightarm-matters">Why &ldquo;leftArm + rightArm&rdquo; matters</h2><p id="z95rfnv_153">Because a path can go:</p><p id="z95rfnv_154"><code class="code" id="z95rfnv_157">(same-value chain down left) &rarr; node &rarr; (same-value chain down right)</code></p><p id="z95rfnv_155">But when returning to parent, you can only choose <span class="control" id="z95rfnv_158">one direction</span>, otherwise it would &ldquo;fork&rdquo;.</p></section><section class="chapter"><h2 id="c-dfs-template-core-logic" data-toc="c-dfs-template-core-logic">C# DFS template (core logic)</h2><div class="code-block" data-lang="csharp">
public class Solution {
    private int best = 0;

    public int LongestUnivaluePath(TreeNode root) {
        Dfs(root);
        return best;
    }

    private int Dfs(TreeNode node) {
        if (node == null) return 0;

        int leftLen = Dfs(node.left);
        int rightLen = Dfs(node.right);

        int leftArm = 0;
        int rightArm = 0;

        if (node.left != null &amp;&amp; node.left.val == node.val)
            leftArm = leftLen + 1;

        if (node.right != null &amp;&amp; node.right.val == node.val)
            rightArm = rightLen + 1;

        best = Math.Max(best, leftArm + rightArm);

        return Math.Max(leftArm, rightArm);
    }
}
</div><p id="z95rfnv_160">You&rsquo;re <span class="control" id="z95rfnv_164">100% right</span> &mdash; this naming <span class="emphasis" id="z95rfnv_165">is</span> confusing. Most people struggle with <span class="control" id="z95rfnv_166"><code class="code" id="z95rfnv_167">leftLen</code> vs <code class="code" id="z95rfnv_168">leftArm</code></span> the first time, so let&rsquo;s fix it properly.</p><p id="z95rfnv_161">I&rsquo;ll do three things:</p><ol class="list _decimal" id="z95rfnv_162" type="1"><li class="list__item" id="z95rfnv_169"><p id="z95rfnv_172"><span class="control" id="z95rfnv_173">Rename variables to human-friendly names</span></p></li><li class="list__item" id="z95rfnv_170"><p id="z95rfnv_174"><span class="control" id="z95rfnv_175">Explain the mental model (what flows UP vs what stays LOCAL)</span></p></li><li class="list__item" id="z95rfnv_171"><p id="z95rfnv_176"><span class="control" id="z95rfnv_177">Re-visualize the same example with the new names</span></p></li></ol></section><section class="chapter"><h2 id="1-the-real-mental-model" data-toc="1-the-real-mental-model">1Ô∏è‚É£ The real mental model</h2><p id="z95rfnv_178">At every node, there are <span class="control" id="z95rfnv_181">two different ideas</span>:</p><section class="chapter"><h3 id="a-what-can-i-send-upward-to-my-parent" data-toc="a-what-can-i-send-upward-to-my-parent">üîπ A) What can I <span class="control" id="z95rfnv_185">send upward</span> to my parent?</h3><aside class="prompt" data-type="tip" data-title="" id="z95rfnv_183"><p id="z95rfnv_186">&ldquo;If my parent has the same value as me, how long of a same-value chain can I extend upward?&rdquo;</p></aside><p id="z95rfnv_184">This must be <span class="control" id="z95rfnv_187">ONE direction only</span> (left <span class="emphasis" id="z95rfnv_188">or</span> right).</p></section><section class="chapter"><h3 id="b-what-is-the-best-path-passing-through-me" data-toc="b-what-is-the-best-path-passing-through-me">üîπ B) What is the <span class="control" id="z95rfnv_193">best path passing through me</span>?</h3><aside class="prompt" data-type="tip" data-title="" id="z95rfnv_190"><p id="z95rfnv_194">&ldquo;If both sides match me, what is the longest path that goes left &rarr; me &rarr; right?&rdquo;</p></aside><p id="z95rfnv_191">This can use <span class="control" id="z95rfnv_195">both sides</span>, but <span class="control" id="z95rfnv_196">cannot be sent upward</span>.</p></section></section><section class="chapter"><h2 id="2-better-naming" data-toc="2-better-naming">2Ô∏è‚É£ Better naming</h2><div class="code-block" data-lang="csharp">
leftDown   // what left child sends upward to me
rightDown  // what right child sends upward to me

leftPath   // same-value path extending from me to left child
rightPath  // same-value path extending from me to right child
</div><p id="z95rfnv_198">üëâ <span class="control" id="z95rfnv_201">Rule of thumb</span></p><ul class="list _bullet" id="z95rfnv_199"><li class="list__item" id="z95rfnv_202"><p id="z95rfnv_204"><code class="code" id="z95rfnv_205">Down</code> = value returned <span class="emphasis" id="z95rfnv_206">from</span> DFS</p></li><li class="list__item" id="z95rfnv_203"><p id="z95rfnv_207"><code class="code" id="z95rfnv_208">Path</code> = value calculated <span class="emphasis" id="z95rfnv_209">at</span> this node</p></li></ul></section><section class="chapter"><h2 id="3-clean-c-code-with-clear-naming" data-toc="3-clean-c-code-with-clear-naming">3Ô∏è‚É£ Clean C# code with clear naming</h2><div class="code-block" data-lang="csharp">
public class Solution {
    private int best = 0;

    public int LongestUnivaluePath(TreeNode root) {
        Dfs(root);
        return best;
    }

    private int Dfs(TreeNode node) {
        if (node == null) return 0;

        int leftDown = Dfs(node.left);
        int rightDown = Dfs(node.right);

        int leftPath = 0;
        int rightPath = 0;

        if (node.left != null &amp;&amp; node.left.val == node.val)
            leftPath = leftDown + 1;

        if (node.right != null &amp;&amp; node.right.val == node.val)
            rightPath = rightDown + 1;

        // path THROUGH this node
        best = Math.Max(best, leftPath + rightPath);

        // path UPWARD to parent
        return Math.Max(leftPath, rightPath);
    }
}
</div></section><section class="chapter"><h2 id="4-visual-walkthrough-with-new-names" data-toc="4-visual-walkthrough-with-new-names">4Ô∏è‚É£ Visual walkthrough with new names</h2><p id="z95rfnv_212">Tree again:</p><div class="code-block" data-lang="none">
----------------------
        A(5)
       /    \
   B(4)     C(5)
            \
             F(5)
</div><section class="chapter"><h3 id="node-f-5" data-toc="node-f-5">Node F(5)</h3><ul class="list _bullet" id="z95rfnv_218"><li class="list__item" id="z95rfnv_220"><p id="z95rfnv_225"><code class="code" id="z95rfnv_226">leftDown=0</code>, <code class="code" id="z95rfnv_227">rightDown=0</code></p></li><li class="list__item" id="z95rfnv_221"><p id="z95rfnv_228">no matching children</p></li><li class="list__item" id="z95rfnv_222"><p id="z95rfnv_229"><code class="code" id="z95rfnv_230">leftPath=0</code>, <code class="code" id="z95rfnv_231">rightPath=0</code></p></li><li class="list__item" id="z95rfnv_223"><p id="z95rfnv_232"><code class="code" id="z95rfnv_233">best = 0</code></p></li><li class="list__item" id="z95rfnv_224"><p id="z95rfnv_234">returns <span class="control" id="z95rfnv_235">0</span></p></li></ul></section><section class="chapter"><h3 id="node-c-5" data-toc="node-c-5">Node C(5)</h3><div class="code-block" data-lang="none">
    C(5)
      \
       F(5)
</div><ul class="list _bullet" id="z95rfnv_237"><li class="list__item" id="z95rfnv_239"><p id="z95rfnv_244"><code class="code" id="z95rfnv_245">leftDown=0</code></p></li><li class="list__item" id="z95rfnv_240"><p id="z95rfnv_246"><code class="code" id="z95rfnv_247">rightDown=0</code></p></li><li class="list__item" id="z95rfnv_241"><p id="z95rfnv_248">right child matches &rarr; <code class="code" id="z95rfnv_249">rightPath = 0 + 1 = 1</code></p></li><li class="list__item" id="z95rfnv_242"><p id="z95rfnv_250">update: <code class="code" id="z95rfnv_251">best = 1</code></p></li><li class="list__item" id="z95rfnv_243"><p id="z95rfnv_252">returns <span class="control" id="z95rfnv_253">1</span> (chain length sent upward)</p></li></ul></section><section class="chapter"><h3 id="node-a-5" data-toc="node-a-5">Node A(5)</h3><div class="code-block" data-lang="none">
        A(5)
           \
            C(5)
              \
               F(5)
</div><ul class="list _bullet" id="z95rfnv_255"><li class="list__item" id="z95rfnv_257"><p id="z95rfnv_262"><code class="code" id="z95rfnv_263">leftDown = 0</code></p></li><li class="list__item" id="z95rfnv_258"><p id="z95rfnv_264"><code class="code" id="z95rfnv_265">rightDown = 1</code></p></li><li class="list__item" id="z95rfnv_259"><p id="z95rfnv_266">right child matches &rarr; <code class="code" id="z95rfnv_267">rightPath = 1 + 1 = 2</code></p></li><li class="list__item" id="z95rfnv_260"><p id="z95rfnv_268">update: <code class="code" id="z95rfnv_269">best = 2</code></p></li><li class="list__item" id="z95rfnv_261"><p id="z95rfnv_270">returns <span class="control" id="z95rfnv_271">2</span></p></li></ul></section></section><section class="chapter"><h2 id="5-one-sentence-rule" data-toc="5-one-sentence-rule">5Ô∏è‚É£ One-sentence rule</h2><aside class="prompt" data-type="tip" data-title="" id="z95rfnv_272"><p id="z95rfnv_274"><span class="control" id="z95rfnv_275">DFS returns the longest same-value chain going DOWN, but <code class="code" id="z95rfnv_276">best</code> tracks the longest path going THROUGH.</span></p></aside></section><div class="last-modified">29 January 2026</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="178-graph-valid-tree.html" class="navigation-links__prev">178: Graph Valid Tree</a><a href="breadth-first-search-bfs.html" class="navigation-links__next">üåê Breadth-First Search (BFS)</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.25.3-b857/app.js"></script></body></html>