<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#57B747"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2026-02-07T22:58:27.1054799"><title>178: Graph Valid Tree | DSA using C#.NET</title><script type="application/json" id="virtual-toc-data">[{"id":"key-idea","level":0,"title":"Key idea","anchor":"#key-idea"},{"id":"approach-a-dfs-bfs-cycle-check-connectivity","level":0,"title":"Approach A: DFS/BFS (cycle check + connectivity)","anchor":"#approach-a-dfs-bfs-cycle-check-connectivity"},{"id":"walkthrough-step-by-step-on-example","level":0,"title":"Walkthrough (step-by-step on example)","anchor":"#walkthrough-step-by-step-on-example"},{"id":"example-that-fails-cycle","level":0,"title":"Example that fails (cycle)","anchor":"#example-that-fails-cycle"},{"id":"example-that-fails-disconnected","level":0,"title":"Example that fails (disconnected)","anchor":"#example-that-fails-disconnected"},{"id":"c-implementation-dfs","level":0,"title":"C# implementation (DFS)","anchor":"#c-implementation-dfs"},{"id":"complexity","level":0,"title":"Complexity","anchor":"#complexity"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.25.3-b857/app.css" rel="stylesheet"><link rel="icon" type="image/png" sizes="16x16" href="https://www.python.org/static/apple-touch-icon-144x144-precomposed.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="178: Graph Valid Tree | DSA using C#.NET"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="DSA using C#.NET Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/https://github.com/jaipanc/CSharpAlgorithms/tree/master/docs/178-graph-valid-tree.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="178: Graph Valid Tree | DSA using C#.NET"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/https://github.com/jaipanc/CSharpAlgorithms/tree/master/docs/178-graph-valid-tree.html#webpage",
    "url": "writerside-documentation/https://github.com/jaipanc/CSharpAlgorithms/tree/master/docs/178-graph-valid-tree.html",
    "name": "178: Graph Valid Tree | DSA using C#.NET",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentationhttps://github.com/jaipanc/CSharpAlgorithms/tree/master/docs/#website",
    "url": "writerside-documentationhttps://github.com/jaipanc/CSharpAlgorithms/tree/master/docs/",
    "name": "DSA using C#.NET Help"
}</script><!-- End Schema.org --></head><body data-id="178-¬∑-Graph-Valid-Tree" data-main-title="178: Graph Valid Tree" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="üå≥-Depth-First-Search-DFS.md|üå≥ Depth-First Search (DFS)"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>DSA using C#.NET  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="178-¬∑-Graph-Valid-Tree" id="178-¬∑-Graph-Valid-Tree.md">178: Graph Valid Tree</h1><p id="v1uqqy_3">Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</p><p id="v1uqqy_4">A graph is a <span class="control" id="v1uqqy_14">valid tree</span> if:</p><ol class="list _decimal" id="v1uqqy_5" type="1"><li class="list__item" id="v1uqqy_15"><p id="v1uqqy_17">It has <span class="control" id="v1uqqy_18">exactly n - 1 edges</span></p></li><li class="list__item" id="v1uqqy_16"><p id="v1uqqy_19">It is <span class="control" id="v1uqqy_20">fully connected</span> (one component) (Equivalently: connected + no cycles)</p></li></ol><section class="chapter"><h2 id="key-idea" data-toc="key-idea">Key idea</h2><p id="v1uqqy_21">In an undirected graph:</p><ul class="list _bullet" id="v1uqqy_22"><li class="list__item" id="v1uqqy_25"><p id="v1uqqy_28">If there&rsquo;s a <span class="control" id="v1uqqy_29">cycle</span> &rarr; not a tree</p></li><li class="list__item" id="v1uqqy_26"><p id="v1uqqy_30">If it&rsquo;s <span class="control" id="v1uqqy_31">disconnected</span> &rarr; not a tree</p></li><li class="list__item" id="v1uqqy_27"><p id="v1uqqy_32">If it has <span class="control" id="v1uqqy_33">n-1 edges</span> and <span class="control" id="v1uqqy_34">no cycle</span>, it must be connected (and is a tree)</p></li></ul><p id="v1uqqy_23">So we can do:</p><section class="chapter"><h3 id="step-1-quick-edge-count-check" data-toc="step-1-quick-edge-count-check">Step 1 &mdash; Quick edge count check</h3><p id="v1uqqy_35">If <code class="code" id="v1uqqy_39">edges.Length != n - 1</code> &rarr; return <code class="code" id="v1uqqy_40">false</code> immediately.</p><p id="v1uqqy_36">Why?</p><ul class="list _bullet" id="v1uqqy_37"><li class="list__item" id="v1uqqy_41"><p id="v1uqqy_44">A tree with <code class="code" id="v1uqqy_45">n</code> nodes always has <code class="code" id="v1uqqy_46">n-1</code> edges.</p></li><li class="list__item" id="v1uqqy_42"><p id="v1uqqy_47">Too many edges &rArr; must contain a cycle.</p></li><li class="list__item" id="v1uqqy_43"><p id="v1uqqy_48">Too few edges &rArr; cannot be fully connected.</p></li></ul></section></section><section class="chapter"><h2 id="approach-a-dfs-bfs-cycle-check-connectivity" data-toc="approach-a-dfs-bfs-cycle-check-connectivity">Approach A: DFS/BFS (cycle check + connectivity)</h2><section class="chapter"><h3 id="step-2-build-adjacency-list" data-toc="step-2-build-adjacency-list">Step 2 &mdash; Build adjacency list</h3><p id="v1uqqy_52">Create <code class="code" id="v1uqqy_56">adj[u]</code> = list of neighbors of <code class="code" id="v1uqqy_57">u</code>.</p><p id="v1uqqy_53">Example: <code class="code" id="v1uqqy_58">n = 5</code> <code class="code" id="v1uqqy_59">edges = [[0,1],[0,2],[0,3],[1,4]]</code></p><p id="v1uqqy_54">Adjacency:</p><ul class="list _bullet" id="v1uqqy_55"><li class="list__item" id="v1uqqy_60"><p id="v1uqqy_65">0: [1,2,3]</p></li><li class="list__item" id="v1uqqy_61"><p id="v1uqqy_66">1: [0,4]</p></li><li class="list__item" id="v1uqqy_62"><p id="v1uqqy_67">2: [0]</p></li><li class="list__item" id="v1uqqy_63"><p id="v1uqqy_68">3: [0]</p></li><li class="list__item" id="v1uqqy_64"><p id="v1uqqy_69">4: [1]</p></li></ul></section><section class="chapter"><h3 id="step-3-dfs-from-node-0" data-toc="step-3-dfs-from-node-0">Step 3 &mdash; DFS from node 0</h3><p id="v1uqqy_70">We track:</p><ul class="list _bullet" id="v1uqqy_71"><li class="list__item" id="v1uqqy_74"><p id="v1uqqy_76"><code class="code" id="v1uqqy_77">visited[]</code></p></li><li class="list__item" id="v1uqqy_75"><p id="v1uqqy_78"><code class="code" id="v1uqqy_79">parent</code> to avoid mistaking the edge back to parent as a cycle</p></li></ul><p id="v1uqqy_72">DFS rule: When exploring <code class="code" id="v1uqqy_80">u -&gt; v</code>:</p><ul class="list _bullet" id="v1uqqy_73"><li class="list__item" id="v1uqqy_81"><p id="v1uqqy_83">if <code class="code" id="v1uqqy_84">v</code> not visited: DFS(v, parent=u)</p></li><li class="list__item" id="v1uqqy_82"><p id="v1uqqy_85">else if <code class="code" id="v1uqqy_86">v != parent</code>: found a <span class="control" id="v1uqqy_87">cycle</span> &rarr; return false</p></li></ul></section><section class="chapter"><h3 id="step-4-after-dfs-check-connectivity" data-toc="step-4-after-dfs-check-connectivity">Step 4 &mdash; After DFS, check connectivity</h3><p id="v1uqqy_88">If any node is not visited &rarr; disconnected &rarr; return false Else true.</p></section></section><section class="chapter"><h2 id="walkthrough-step-by-step-on-example" data-toc="walkthrough-step-by-step-on-example">Walkthrough (step-by-step on example)</h2><p id="v1uqqy_90"><code class="code" id="v1uqqy_96">n=5</code>, edges as above.</p><p id="v1uqqy_91"><span class="control" id="v1uqqy_97">Edge count:</span> 4 == 5-1 ‚úÖ</p><p id="v1uqqy_92">Start DFS(0, parent=-1)</p><ul class="list _bullet" id="v1uqqy_93"><li class="list__item" id="v1uqqy_98"><p id="v1uqqy_99">Visit 0</p><ul class="list _bullet" id="v1uqqy_100"><li class="list__item" id="v1uqqy_101"><p id="v1uqqy_104">neighbor 1 (unvisited) &rarr; DFS(1, parent=0)</p><ul class="list _bullet" id="v1uqqy_105"><li class="list__item" id="v1uqqy_106"><p id="v1uqqy_108">Visit 1</p><ul class="list _bullet" id="v1uqqy_109"><li class="list__item" id="v1uqqy_110"><p id="v1uqqy_113">neighbor 0 (visited BUT it&rsquo;s parent) &rarr; ignore</p></li><li class="list__item" id="v1uqqy_111"><p id="v1uqqy_114">neighbor 4 (unvisited) &rarr; DFS(4, parent=1)</p><ul class="list _bullet" id="v1uqqy_115"><li class="list__item" id="v1uqqy_116"><p id="v1uqqy_118">Visit 4</p></li><li class="list__item" id="v1uqqy_117"><p id="v1uqqy_119">neighbor 1 is parent &rarr; ignore</p></li></ul></li><li class="list__item" id="v1uqqy_112"><p id="v1uqqy_120">done 4</p></li></ul></li><li class="list__item" id="v1uqqy_107"><p id="v1uqqy_121">done 1</p></li></ul></li><li class="list__item" id="v1uqqy_102"><p id="v1uqqy_122">neighbor 2 (unvisited) &rarr; DFS(2, parent=0) (2 only connects back to 0)</p></li><li class="list__item" id="v1uqqy_103"><p id="v1uqqy_123">neighbor 3 (unvisited) &rarr; DFS(3, parent=0)</p></li></ul></li></ul><p id="v1uqqy_94">All nodes visited ‚úÖ and no cycle ‚úÖ &rarr; <span class="control" id="v1uqqy_124">true</span></p></section><section class="chapter"><h2 id="example-that-fails-cycle" data-toc="example-that-fails-cycle">Example that fails (cycle)</h2><p id="v1uqqy_125"><code class="code" id="v1uqqy_128">n=3</code>, <code class="code" id="v1uqqy_129">edges=[[0,1],[1,2],[2,0]]</code></p><p id="v1uqqy_126">Edge count = 3, but <code class="code" id="v1uqqy_130">n-1 = 2</code> ‚ùå Return false immediately.</p></section><section class="chapter"><h2 id="example-that-fails-disconnected" data-toc="example-that-fails-disconnected">Example that fails (disconnected)</h2><p id="v1uqqy_131"><code class="code" id="v1uqqy_134">n=4</code>, <code class="code" id="v1uqqy_135">edges=[[0,1],[2,3],[1,0]]</code></p><p id="v1uqqy_132">Edge count is 3, <code class="code" id="v1uqqy_136">n-1 = 3</code> ‚úÖ, but graph has 2 components. DFS from 0 visits only {0,1}. Nodes {2,3} unvisited &rarr; false.</p></section><section class="chapter"><h2 id="c-implementation-dfs" data-toc="c-implementation-dfs">C# implementation (DFS)</h2><div class="code-block" data-lang="csharp">
public bool ValidTree(int n, int[][] edges)
{
    if (edges.Length != n - 1) return false;

    var adj = new List&lt;int&gt;[n];
    for (int i = 0; i &lt; n; i++) adj[i] = new List&lt;int&gt;();

    foreach (var e in edges)
    {
        int u = e[0], v = e[1];
        adj[u].Add(v);
        adj[v].Add(u);
    }

    var visited = new bool[n];

    bool HasCycle(int node, int parent)
    {
        visited[node] = true;

        foreach (var nei in adj[node])
        {
            if (!visited[nei])
            {
                if (HasCycle(nei, node)) return true;
            }
            else if (nei != parent)
            {
                return true; // cycle found
            }
        }
        return false;
    }

    if (HasCycle(0, -1)) return false;

    // connectivity check
    for (int i = 0; i &lt; n; i++)
        if (!visited[i]) return false;

    return true;
}
</div></section><section class="chapter"><h2 id="complexity" data-toc="complexity">Complexity</h2><ul class="list _bullet" id="v1uqqy_139"><li class="list__item" id="v1uqqy_141"><p id="v1uqqy_144">Build adjacency: <code class="code" id="v1uqqy_145">O(n + e)</code></p></li><li class="list__item" id="v1uqqy_142"><p id="v1uqqy_146">DFS traversal: <code class="code" id="v1uqqy_147">O(n + e)</code></p></li><li class="list__item" id="v1uqqy_143"><p id="v1uqqy_148">Memory: <code class="code" id="v1uqqy_149">O(n + e)</code></p></li></ul></section><div class="last-modified">08 February 2026</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="depth-first-search-dfs.html" class="navigation-links__prev">üå≥ Depth-First Search (DFS)</a><a href="687-longest-univalue-path.html" class="navigation-links__next">687: Longest Univalue Path</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.25.3-b857/app.js"></script></body></html>